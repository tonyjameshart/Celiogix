# path: panels/pantry_panel.py
# PantryPanel: UI for pantry inventory with Add button, right-click actions, and UPC lookup
# Sections: Imports / Constants / Schema / Class PantryPanel / Public helpers

from __future__ import annotations
import re
import sqlite3
import tkinter as tk
from dataclasses import dataclass
from tkinter import ttk, messagebox
from typing import Any, List, Tuple, Optional

from panels.base_panel import BasePanel

# Optional libraries
try:
    import requests
except Exception:
    requests = None

# Optional gluten classifier
try:
    from services.gf_safety import classify_pantry_item, get_display_symbol
    GF_AVAILABLE = True
except Exception:
    GF_AVAILABLE = False

# ---------- Columns ----------
COLS: List[Tuple[str, str, int, str]] = [
    ("name",        "Name",        220, "w"),
    ("brand",       "Brand",       140, "w"),
    ("category",    "Category",    120, "w"),
    ("subcategory", "SubCategory", 140, "w"),
    ("net_weight",  "Net.Wt",       70, "e"),
    ("unit",        "Unit",         60, "c"),
    ("quantity",    "Quantity",     80, "e"),
    ("store",       "Store",       100, "w"),
    ("expiration",  "Expiration",  110, "c"),
    ("gf_flag",     "GF",           80, "c"),
    ("tags",        "Tags",        160, "w"),
    ("upc",         "UPC",         140, "w"),
    ("notes",       "Notes",       220, "w"),
]

STRETCHABLE = {"name", "brand", "notes", "tags"}

# ---------- Schema ----------
@dataclass(frozen=True)
class PantrySchema:
    name: bool; brand: bool; category: bool; subcategory: bool; store: bool; tags: bool; notes: bool
    gf_col: Optional[str]; net_weight_col: Optional[str]; qty_col: Optional[str]; thresh_col: Optional[str]

    @staticmethod
    def detect(db: sqlite3.Connection) -> "PantrySchema":
        try:
            cols = {str(r[1]).lower() for r in db.execute("PRAGMA table_info(pantry)").fetchall()}
        except Exception:
            cols = set()

        def has(c: str) -> bool:
            return c in cols

        def one(opts):
            for c in opts:
                if c in cols:
                    return c
            return None

        return PantrySchema(
            has("name"), has("brand"), has("category"), has("subcategory"),
            has("store"), has("tags"), has("notes"),
            one(["gf_flag", "gluten_free", "gf"]),
            one(["net_weight", "netwt", "weight"]),
            one(["qty", "quantity"]),
            one(["thresh", "threshold", "min_qty"])
        )

# ---------- Class PantryPanel ----------
class PantryPanel(BasePanel):
    """
    Panel that lists pantry items. Provides:
    - Add button
    - Right-click menu: Add, Edit, Duplicate, Delete, Copy name, Reclassify GF (item)
    - UPC lookup on add/edit dialog (local DB then OpenFoodFacts)
    """

    # ---- initialization ----
    def __init__(self, master, app, **kw):
        self._schema: Optional[PantrySchema] = None
        self._tree_cat: Optional[ttk.Treeview] = None
        self._tree: Optional[ttk.Treeview] = None
        self._search_var: Optional[tk.StringVar] = None
        self._selected_cat: Optional[str] = None
        self._selected_sub: Optional[str] = None
        self._context_menu: Optional[tk.Menu] = None

        super().__init__(master, app, **kw)

    # ---- build UI ----
    def build(self) -> None:
        self.grid_rowconfigure(1, weight=1)
        self.grid_columnconfigure(1, weight=1)

        # Left groups
        left = ttk.Frame(self, padding=(6, 6))
        left.grid(row=1, column=0, sticky="nsw")
        ttk.Label(left, text="Pantry Groups").pack(anchor="w", pady=(0, 4))
        self._tree_cat = ttk.Treeview(left, show="tree", height=22)
        self._tree_cat.pack(fill="both", expand=True)
        self._tree_cat.bind("<<TreeviewSelect>>", self._on_pick_group)

        # Right side
        right = ttk.Frame(self, padding=(6, 6))
        right.grid(row=1, column=1, sticky="nsew")
        right.grid_rowconfigure(2, weight=1)
        right.grid_columnconfigure(0, weight=1)

        sbar, svar, _ = self.build_search_bar(parent=right, on_return=lambda _q: self.refresh_list(), refresh_text="Refresh")
        self._search_var = svar
        sbar.grid(row=0, column=0, sticky="ew")

        actions = ttk.Frame(right)
        actions.grid(row=1, column=0, sticky="ew", pady=(4, 4))
        ttk.Button(actions, text="Add", command=self._on_add_button).pack(side="left")
        ttk.Button(actions, text="Show All", command=self._show_all).pack(side="left", padx=(6, 0))
        ttk.Button(actions, text="Reclassify GF", command=self._reclassify_gf).pack(side="left", padx=(6, 0))
        ttk.Button(actions, text="Fit Columns", command=lambda: self.fit_columns_now(self._tree, exact=True, max_px_map={"notes":1600, "tags":1200})).pack(side="left", padx=(6, 0))
        ttk.Button(actions, text="Export visible", command=self._export_visible).pack(side="left", padx=(6, 0))

        wrap, tv, _, _ = self.make_scrolling_tree(right, [c[0] for c in COLS])
        for key, hdr, width, align in COLS:
            tv.heading(key, text=hdr)
            tv.column(key, width=width, anchor={"w":"w", "e":"e", "c":"center"}.get(align, "w"), stretch=False)
        wrap.grid(row=2, column=0, sticky="nsew")
        self._tree = tv

        # Tags for GF colorization
        tv.tag_configure("gf_safe", background="#D1FAE5", foreground="#065F46")
        tv.tag_configure("gf_risk", background="#FEE2E2", foreground="#991B1B")
        tv.tag_configure("gf_advisory", background="#FEF2F2", foreground="#7F1D1D")

        # schema detection and initial population
        self._schema = PantrySchema.detect(self.db)
        self.refresh_groups()
        self.refresh_list()
        self.after(0, lambda: self.fit_columns_now(tv, exact=True, max_px_map={"notes":1600, "tags":1200}))

        # bindings
        tv.bind("<Double-1>", self._on_item_double_click)
        self._build_context_menu()
        tv.bind("<Button-3>", self._on_right_click)  # Windows / X11
        tv.bind("<Button-2>", self._on_right_click)  # macOS variant

    # ---- Event handlers (bound in build) ----
    def _on_pick_group(self, event: Any = None) -> None:
        t = self._tree_cat
        if not isinstance(t, ttk.Treeview):
            return
        sel = t.selection()
        if not sel:
            self._selected_cat = None
            self._selected_sub = None
            self.refresh_list()
            return

        iid = sel[0]
        if iid == "root::all":
            self._selected_cat = None
            self._selected_sub = None
        elif iid.startswith("cat::"):
            self._selected_cat = iid.split("::", 1)[1]
            self._selected_sub = None
        elif iid.startswith("sub::"):
            parts = iid.split("::", 2)
            self._selected_cat = parts[1] if len(parts) > 1 else None
            self._selected_sub = parts[2] if len(parts) > 2 else None
        else:
            self._selected_cat = None
            self._selected_sub = None

        self.refresh_list()

    def _on_right_click(self, event: Any) -> None:
        tv = self._tree
        if not isinstance(tv, ttk.Treeview) or self._context_menu is None:
            return
        rowid = tv.identify_row(event.y)
        if rowid:
            try:
                tv.selection_set(rowid)
            except Exception:
                pass
        try:
            self._context_menu.tk_popup(event.x_root, event.y_root)
        finally:
            self._context_menu.grab_release()

    def _on_item_double_click(self, event: Any) -> None:
        tv = self._tree
        if not isinstance(tv, ttk.Treeview):
            return
        iid = tv.identify_row(event.y)
        if not iid:
            return
        if iid.startswith("row::"):
            try:
                real_id = int(iid.split("::", 1)[1])
            except Exception:
                return
            row = self.db.execute("SELECT * FROM pantry WHERE id=?", (real_id,)).fetchone()
            if row:
                item_dict = {col: row[col] for col in row.keys()}
                self._open_edit_dialog(item_dict)

    # ---- Context menu ----
    def _build_context_menu(self) -> None:
        m = tk.Menu(self, tearoff=0)
        m.add_command(label="Add", command=self._on_add_button)
        m.add_separator()
        m.add_command(label="Edit", command=self._ctx_edit_selected)
        m.add_command(label="Duplicate", command=self._ctx_duplicate_selected)
        m.add_command(label="Delete", command=self._ctx_delete_selected)
        m.add_separator()
        m.add_command(label="Copy name", command=self._ctx_copy_name)
        m.add_command(label="Reclassify GF (item)", command=self._ctx_reclassify_item)
        self._context_menu = m

    def _ctx_selected_iid(self) -> Optional[str]:
        tv = self._tree
        if not isinstance(tv, ttk.Treeview):
            return None
        sel = tv.selection()
        return sel[0] if sel else None

    def _ctx_edit_selected(self) -> None:
        iid = self._ctx_selected_iid()
        if iid and iid.startswith("row::"):
            try:
                real_id = int(iid.split("::", 1)[1])
            except Exception:
                return
            row = self.db.execute("SELECT * FROM pantry WHERE id=?", (real_id,)).fetchone()
            if row:
                item_dict = {col: row[col] for col in row.keys()}
                self._open_edit_dialog(item_dict)

    def _ctx_duplicate_selected(self) -> None:
        iid = self._ctx_selected_iid()
        if not iid or not iid.startswith("row::"):
            return
        try:
            real_id = int(iid.split("::", 1)[1])
        except Exception:
            return
        row = self.db.execute("SELECT * FROM pantry WHERE id=?", (real_id,)).fetchone()
        if not row:
            return
        data = {k: row[k] for k in row.keys() if k != "id"}
        cols = ", ".join(data.keys())
        placeholders = ", ".join(["?"] * len(data))
        self.db.execute(f"INSERT INTO pantry ({cols}) VALUES ({placeholders})", tuple(data.values()))
        self.db.commit()
        self.refresh_groups()
        self.refresh_list()

    def _ctx_delete_selected(self) -> None:
        iid = self._ctx_selected_iid()
        if not iid or not iid.startswith("row::"):
            return
        try:
            real_id = int(iid.split("::", 1)[1])
        except Exception:
            return
        if not messagebox.askyesno("Delete", f"Delete pantry item id {real_id}?", parent=self.winfo_toplevel()):
            return
        try:
            self.db.execute("DELETE FROM pantry WHERE id=?", (real_id,))
            self.db.commit()
            self.refresh_groups()
            self.refresh_list()
        except Exception as e:
            messagebox.showerror("Error", f"Delete failed: {e}", parent=self.winfo_toplevel())

    def _ctx_copy_name(self) -> None:
        iid = self._ctx_selected_iid()
        if not iid or not iid.startswith("row::"):
            return
        try:
            real_id = int(iid.split("::", 1)[1])
        except Exception:
            return
        row = self.db.execute("SELECT name FROM pantry WHERE id=?", (real_id,)).fetchone()
        if not row:
            return
        try:
            self.clipboard_clear()
            self.clipboard_append(row["name"] or "")
        except Exception:
            pass

    def _ctx_reclassify_item(self) -> None:
        if not GF_AVAILABLE:
            messagebox.showinfo("GF Classification", "GF safety module not available.", parent=self.winfo_toplevel())
            return
        iid = self._ctx_selected_iid()
        if not iid or not iid.startswith("row::"):
            return
        try:
            real_id = int(iid.split("::", 1)[1])
        except Exception:
            return
        row = self.db.execute("SELECT rowid, * FROM pantry WHERE id=?", (real_id,)).fetchone()
        if not row:
            return
        try:
            item_dict = {col: row[col] for col in row.keys()}
            result = classify_pantry_item(item_dict)
            new_flag = "GF" if result.is_safe else ("RISK" if result.risk_score > 0 else "UNKNOWN")
            self.db.execute("UPDATE pantry SET gf_flag=? WHERE rowid=?", (new_flag, row["rowid"]))
            self.db.commit()
            self.refresh_list()
        except Exception as e:
            messagebox.showerror("Error", f"Reclassify failed: {e}", parent=self.winfo_toplevel())

    # ---- Add / Edit dialog (with UPC lookup) ----
    def _on_add_button(self) -> None:
        empty = {"id": None, "name": "", "brand": "", "category": "", "tags": "", "upc": "", "notes": ""}
        self._open_edit_dialog(empty)

    def _open_edit_dialog(self, item: dict[str, Any]) -> None:
        dlg = tk.Toplevel(self)
        dlg.title(f"{'Add' if not item.get('id') else 'Edit'} Pantry Item")
        dlg.transient(self.winfo_toplevel())
        dlg.grab_set()
        fields = ["name", "brand", "category", "tags", "upc", "notes"]
        entries: dict[str, ttk.Entry] = {}

        for i, field in enumerate(fields):
            ttk.Label(dlg, text=field.capitalize()).grid(row=i, column=0, sticky="w", padx=4, pady=2)
            e = ttk.Entry(dlg)
            e.insert(0, item.get(field, "") or "")
            e.grid(row=i, column=1, sticky="ew", padx=4, pady=2)
            entries[field] = e

            # place UPC lookup button in UPC row
            if field == "upc":
                btn = ttk.Button(dlg, text="Lookup UPC", command=lambda: self._lookup_upc(entries["upc"].get().strip(), entries, dlg))
                btn.grid(row=i, column=2, sticky="w", padx=(6, 4), pady=2)

        def on_save():
            vals = {f: entries[f].get().strip() for f in fields}
            # Ensure column names match your DB. This assumes lowercase column names like 'upc'.
            try:
                if not item.get("id"):
                    cols = ", ".join(vals.keys())
                    placeholders = ", ".join(["?"] * len(vals))
                    self.db.execute(f"INSERT INTO pantry ({cols}) VALUES ({placeholders})", tuple(vals.values()))
                else:
                    sets = ", ".join([f"{k}=?" for k in vals.keys()])
                    params = list(vals.values()) + [item["id"]]
                    self.db.execute(f"UPDATE pantry SET {sets} WHERE id=?", params)
                self.db.commit()
                dlg.destroy()
                self.refresh_groups()
                self.refresh_list()
            except Exception as e:
                messagebox.showerror("Error", f"Save failed: {e}", parent=dlg)

        btn_frame = ttk.Frame(dlg)
        btn_frame.grid(row=len(fields), column=0, columnspan=3, pady=(6, 6))
        ttk.Button(btn_frame, text="Save", command=on_save).pack(side="left")
        ttk.Button(btn_frame, text="Cancel", command=dlg.destroy).pack(side="left", padx=(6, 0))

    def _lookup_upc(self, upc: str, entries: dict[str, ttk.Entry], parent_dlg: Optional[tk.Toplevel] = None) -> None:
        """Lookup UPC locally then via OpenFoodFacts. Populate entries if found."""
        parent = parent_dlg or self.winfo_toplevel()
        if not upc:
            messagebox.showinfo("UPC Lookup", "Enter a UPC to lookup.", parent=parent)
            return

        # 1) Local DB lookup (pantry table)
        try:
            row = self.db.execute("SELECT * FROM pantry WHERE lower(upc)=lower(?)", (upc,)).fetchone()
        except Exception:
            row = None

        if row:
            try:
                entries.get("name").delete(0, "end"); entries.get("name").insert(0, row["name"] or "")
                entries.get("brand").delete(0, "end"); entries.get("brand").insert(0, row["brand"] or "")
                entries.get("category").delete(0, "end"); entries.get("category").insert(0, row["category"] or "")
                entries.get("tags").delete(0, "end"); entries.get("tags").insert(0, row["tags"] or "")
                entries.get("notes").delete(0, "end"); entries.get("notes").insert(0, row["notes"] or "")
            except Exception:
                pass
            messagebox.showinfo("UPC Lookup", "Found product in local database. Fields populated.", parent=parent)
            return

        # 2) Online lookup via OpenFoodFacts
        if requests is None:
            messagebox.showinfo("UPC Lookup", "Requests library not available. Install `requests` to enable online UPC lookup.", parent=parent)
            return

        try:
            url = f"https://world.openfoodfacts.org/api/v0/product/{upc}.json"
            resp = requests.get(url, timeout=8)
            if not resp.ok:
                raise RuntimeError(f"HTTP {resp.status_code}")
            data = resp.json()
        except Exception as e:
            messagebox.showinfo("UPC Lookup", f"Online lookup failed: {e}", parent=parent)
            return

        if data.get("status") != 1:
            messagebox.showinfo("UPC Lookup", "Product not found by OpenFoodFacts.", parent=parent)
            return

        prod = data.get("product", {})
        name = prod.get("product_name") or prod.get("generic_name") or ""
        brand = prod.get("brands") or ""
        categories = prod.get("categories") or ""
        quantity = prod.get("quantity") or ""
        ingredients = prod.get("ingredients_text") or ""
        labels = prod.get("labels") or ""

        try:
            entries.get("name").delete(0, "end"); entries.get("name").insert(0, name)
            entries.get("brand").delete(0, "end"); entries.get("brand").insert(0, brand)
            entries.get("category").delete(0, "end"); entries.get("category").insert(0, categories)
            entries.get("tags").delete(0, "end"); entries.get("tags").insert(0, labels if isinstance(labels, str) else ", ".join(labels))
            entries.get("notes").delete(0, "end"); entries.get("notes").insert(0, ingredients or quantity)
            entries.get("upc").delete(0, "end"); entries.get("upc").insert(0, upc)
        except Exception:
            pass

        messagebox.showinfo("UPC Lookup", "Online product data retrieved and fields populated.", parent=parent)

    # ---- Reclassify all GF ----
    def _reclassify_gf(self) -> None:
        if not GF_AVAILABLE:
            messagebox.showinfo("GF Classification", "GF safety module not available.", parent=self.winfo_toplevel())
            return

        if not messagebox.askyesno(
            "Reclassify GF",
            "This will analyze all pantry items for gluten content.\n\n"
            "Items with explicit gf_flag values (GF, RISK) will NOT be overridden.\n\n"
            "Continue?",
            parent=self.winfo_toplevel()
        ):
            return

        try:
            rows = self.db.execute("SELECT rowid, * FROM pantry").fetchall()
            updated = 0

            for r in rows:
                item_dict = {col: r[col] for col in r.keys()}
                result = classify_pantry_item(item_dict)
                existing = (item_dict.get("gf_flag") or "").strip().upper()
                if existing in ("GF", "SAFE", "RISK", "NGF"):
                    continue
                if result.risk_score >= 999:
                    new_flag = "RISK"
                elif result.is_safe:
                    new_flag = "GF"
                elif result.risk_score > 0:
                    new_flag = "RISK"
                else:
                    new_flag = "UNKNOWN"
                self.db.execute("UPDATE pantry SET gf_flag=? WHERE rowid=?", (new_flag, r["rowid"]))
                updated += 1

            self.db.commit()
            self.refresh_list()
            messagebox.showinfo(
                "Reclassification Complete",
                f"Analyzed {len(rows)} items.\nUpdated {updated} items.\n{len(rows) - updated} items kept existing flags.",
                parent=self.winfo_toplevel()
            )
        except Exception as e:
            messagebox.showerror("Error", f"Reclassification failed:\n{e}", parent=self.winfo_toplevel())

    # ---- Refresh / render ----
    def refresh_groups(self) -> None:
        t = self._tree_cat
        if not isinstance(t, ttk.Treeview):
            return
        for iid in t.get_children(""):
            t.delete(iid)
        try:
            rows = self.db.execute(
                """
                SELECT COALESCE(category,'') AS category,
                       COALESCE(subcategory,'') AS subcategory,
                       COUNT(*) AS n
                  FROM pantry
                 GROUP BY category, subcategory
                 ORDER BY LOWER(category), LOWER(subcategory)
                """
            ).fetchall()
        except Exception:
            rows = []

        totals: dict[str, dict[str, int]] = {}
        for r in rows:
            cat = r["category"] or ""
            sub = r["subcategory"] or ""
            totals.setdefault(cat, {})[sub] = int(r["n"] or 0)

        total_all = sum(sum(d.values()) for d in totals.values())
        t.insert("", "end", iid="root::all", text=f"All ({total_all})", open=True)
        for cat in sorted(totals.keys(), key=str.lower):
            ci = f"cat::{cat}"
            t.insert("", "end", iid=ci, text=f"{cat or '(Uncategorized)'} ({sum(totals[cat].values())})", open=False)
            for sub, cnt in sorted(totals[cat].items(), key=lambda kv: kv[0].lower()):
                t.insert(ci, "end", iid=f"sub::{cat}::{sub}", text=f"{sub or '(None)'} ({cnt})", open=False)
        try:
            t.selection_set("root::all")
        except Exception:
            pass

    def refresh_list(self) -> None:
        tv = self._tree
        if not isinstance(tv, ttk.Treeview):
            return
        for iid in tv.get_children(""):
            tv.delete(iid)

        s = self._schema or PantrySchema.detect(self.db)
        gf = s.gf_col or "''"
        netw = s.net_weight_col or "''"
        qty = s.qty_col or "0"
        thr = s.thresh_col or "0"
        select_parts = [
            "rowid AS _id",
            "COALESCE(name,'') AS name" if s.name else "'' AS name",
            "COALESCE(brand,'') AS brand" if s.brand else "'' AS brand",
            "COALESCE(category,'') AS category" if s.category else "'' AS category",
            "COALESCE(subcategory,'') AS subcategory" if s.subcategory else "'' AS subcategory",
            "COALESCE(store,'') AS store" if s.store else "'' AS store",
            f"COALESCE({gf}, '') AS gf_flag",
            f"COALESCE({netw}, '') AS net_weight",
            f"COALESCE({qty}, 0) AS qty",
            f"COALESCE({thr}, 0) AS thresh",
            "COALESCE(tags,'') AS tags" if s.tags else "'' AS tags",
            "COALESCE(notes,'') AS notes" if s.notes else "'' AS notes",
            "COALESCE(upc, '') AS upc",
        ]
        sql = f"SELECT {', '.join(select_parts)} FROM pantry"
        where, params = [], []
        if self._selected_cat is not None:
            if self._selected_cat == "":
                where.append("(category IS NULL OR category = '')")
            else:
                where.append("category = ?")
                params.append(self._selected_cat)
        if self._selected_sub is not None:
            if self._selected_sub == "":
                where.append("(subcategory IS NULL OR subcategory = '')")
            else:
                where.append("subcategory = ?")
                params.append(self._selected_sub)

        q = ""
        try:
            q = (self._search_var.get() if self._search_var else "").strip()
        except Exception:
            q = ""
        if q:
            like = f"%{re.sub(r'([%_\\\\])', r'\\\\\\1', q)}%"
            where.append("(name LIKE ? ESCAPE '\\' OR brand LIKE ? ESCAPE '\\' OR tags LIKE ? ESCAPE '\\' OR notes LIKE ? ESCAPE '\\')")
            params.extend([like, like, like, like])

        if where:
            sql += " WHERE " + " AND ".join(where)
        sql += " ORDER BY LOWER(category), LOWER(subcategory), LOWER(name)"

        try:
            rows = self.db.execute(sql, params).fetchall()
        except Exception:
            rows = []

        def _val(r: sqlite3.Row, key: str) -> str:
            try:
                return r[key] if key in r.keys() else ""
            except Exception:
                return ""

        for r in rows:
            tags = []
            gf_display = _val(r, "gf_flag") or ""
            if GF_AVAILABLE:
                try:
                    result = classify_pantry_item({col: r[col] for col in r.keys()})
                    gf_display = get_display_symbol(result)
                    if result.risk_score >= 999:
                        tags.append("gf_advisory")
                    elif result.risk_score > 0:
                        tags.append("gf_risk")
                    elif result.is_safe:
                        tags.append("gf_safe")
                except Exception:
                    pass

            tv.insert("", "end", iid=f"row::{r['_id']}",
                      values=[
                          _val(r, "name"),
                          _val(r, "brand"),
                          _val(r, "category"),
                          _val(r, "subcategory"),
                          _val(r, "net_weight"),
                          _val(r, "unit"),
                          _val(r, "qty"),
                          _val(r, "store"),
                          _val(r, "expiration"),
                          gf_display,
                          _val(r, "tags"),
                          _val(r, "upc"),
                          _val(r, "notes"),
                      ],
                      tags=tuple(tags))
        self.fit_columns_now(tv, exact=True, max_px_map={"notes":1600, "tags":1200})

    # ---- Export / utilities ----
    def _export_visible(self) -> None:
        tv = self._tree
        if isinstance(tv, ttk.Treeview):
            items = tv.get_children()
            rows = [list(tv.item(i, "values")) for i in items]
            headings = [hdr for _k, hdr, _w, _a in COLS]
            try:
                from utils.export import export_table_html
                export_table_html(
                    path=None,
                    title="Pantry Inventory",
                    columns=headings,
                    rows=rows,
                    subtitle="Exported from Celiogix Pantry",
                    meta={"Count": len(rows), "GF Classified": "Yes" if GF_AVAILABLE else "No"},
                    open_after=True,
                )
            except Exception:
                messagebox.showinfo("Export", "Export module not available.", parent=self.winfo_toplevel())

    def _show_all(self) -> None:
        self._selected_cat = None
        self._selected_sub = None
        try:
            if isinstance(self._tree_cat, ttk.Treeview):
                self._tree_cat.selection_set("root::all")
        except Exception:
            pass
        self.refresh_list()
